---
titleTemplate: 常见问题 | Composer中文文档 - PHP 的依赖管理器 | PHP | noob-coder | 菜鸟码农
aside: false
head:
  - - meta
    - name: keywords
      content: 依赖冲突,Private Packagist,自定义仓库,VCS,packagist,递归加载仓库,composer.json,vendor,Composer,依赖管理器,PHP,libraries,dependency,noob-coder,菜鸟码农
  - - meta
    - name: description
      content: 在使用自定义仓库时，你可能会遇到问题，因为 Composer 不会加载你的依赖项的仓库，所以你必须在所有的 composer.json 文件中重新定义这些仓库。
---

# 为什么 Composer 不能递归加载仓库？

在使用自定义仓库时，你可能会遇到问题，因为 Composer 不会加载你的依赖项的仓库，所以你必须在所有的 `composer.json` 文件中重新定义这些仓库。

在详细解释为什么会这样之前，你必须理解自定义 VCS 和包仓库的主要用途是临时尝试一些东西，或者在你的拉取请求被合并之前使用项目的一个分支等。你不应该使用它们来跟踪私有包。为此，你应该考虑使用 [Private Packagist](https://packagist.com)，它允许你在一处配置所有私有包，并避免了内联 VCS 仓库相关的减速问题。

依赖解析器可以通过三种方式处理自定义仓库：

- 获取根包的仓库，从定义的仓库中获取所有包，然后解析依赖要求。这是当前的状态，它运行良好，除了不能递归加载仓库这个限制。

- 获取根包的仓库，在从定义的仓库初始化包的同时，递归初始化在这些包中找到的所有仓库，以及它们的包的包等，然后解析依赖要求。这可能可行，但由于每个 VCS 仓库可能需要几秒钟，会大大减慢初始化速度，并且可能最终处于完全崩溃的状态，因为一个包的多个版本可能在包仓库中定义相同的包，但具有不同的 dist/source。这有很多可能出错的方式。

- 获取根包的仓库，然后获取第一层依赖的仓库，再获取它们依赖的仓库等，最后解析依赖要求。这听起来更高效，但它与第二种解决方案有相同的问题，因为加载依赖的仓库并不像听起来那么容易。你需要加载一个依赖要求的所有潜在匹配的仓库，而这可能又会有冲突的包定义。
